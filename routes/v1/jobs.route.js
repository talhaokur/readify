import { HttpStatusCode } from 'axios';
import { Router } from 'express';
import fs from 'node:fs';
import * as path from 'path';
import { GLOBALS } from '../../configs.js';
import NotImplementedError from '../../errors/not-implemented.error.js';
import { epubService } from '../../services/epub.service.js';
import { jobContainerService } from '../../services/jobcontainer.service.js';
import { PageService } from '../../services/page.service.js';
import InvalidRequestError from '../../errors/invalid-request.error.js';
import Page from '../../models/page.model.js';

const router = Router();

function isValidUUID(uuid) {
    const regex = /^[0-9a-f]{8}-[0-9a-f]{4}-[4][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i;
    return regex.test(uuid);
}

function getEntityURL(req, id) {
    const requestUrl = req.protocol + '://' + req.get('host') + req.originalUrl;
    return new URL(`${requestUrl}/${id}`, requestUrl);
}

function validatePostRequestParams(resBody) {
    const { urls, title } = resBody;

    if (!urls) {
        throw new InvalidRequestError("urls cannot be null!");
    }

    if (!urls instanceof Array) {
        throw new InvalidRequestError("urls must be an array!");
    }

    if (urls.length === 0) {
        throw new InvalidRequestError("urls must contain at least one item!");
    }

    if (urls.some(item => item === null || item === "")) {
        throw new InvalidRequestError("urls cannot contain null or empty string values!");
    }

    if (!title) {
        throw new InvalidRequestError("title is mandatory!");
    }
}

function getPages(urls) {
    const pages = [];

    urls.forEach(url => {
        pages.push(new Page(url));
    });

    return pages;
}

router.post('/', async (req, res, next) => {
    const { urls, title, author, coverImageUrl } = req.body;

    try {
        validatePostRequestParams(req.body);
        const [jobId, repo] = await jobContainerService.initializeJob();
        const pages = getPages(urls);
        const pgs = new PageService(pages, repo);
        await pgs.loadPages();

        const options = {
            title: title,
            author: author || 'readify',
            publisher: 'Generated by readify app',
            version: 3,
            content: pgs.getAllContent(),
            cover: coverImageUrl || '',
        };

        const epubFilePath = path.join(repo, `${title}.epub`);
        await epubService.generateEpub(options, epubFilePath);
        jobContainerService.deleteImageRepositoryForJob(jobId);
        const entityUrl = getEntityURL(req, jobId);
        return res.status(HttpStatusCode.Created).json({ jobId: jobId, entityUrl: entityUrl });
    } catch (error) {
        next(error);
    }
});

router.get('/', (req, res) => {
    throw new NotImplementedError("this feature is not implemented yet");
});

router.get("/:uuid", async (req, res, next) => {
    const { uuid } = req.params;
    if (!isValidUUID(uuid))
        return res.status(HttpStatusCode.BadRequest).json({ message: `Given id is not valid` });

    const jobRepository = path.join(GLOBALS.outputDir, uuid);

    if (!fs.existsSync(jobRepository))
        return res.status(HttpStatusCode.NotFound).json({ message: `No job found with id:${uuid}` });

    try {
        const epubPath = epubService.getEpubFilePath(uuid, jobRepository);
        return res.download(epubPath);
    } catch (error) {
        next(error);
    }
});

router.delete("/:uuid", (req, res, next) => {
    const { uuid } = req.params;
    if (!isValidUUID(uuid))
        return res.status(HttpStatusCode.BadRequest).json({ message: `Given id is not valid` });

    const jobRepository = path.join(GLOBALS.outputDir, uuid);

    if (!fs.existsSync(jobRepository))
        return res.status(HttpStatusCode.NotFound).json({ message: `No job found with id:${uuid}` });

    try {
        jobContainerService.deleteRepository(uuid);
        return res.status(HttpStatusCode.Ok).json({ message: `Job ${uuid} deleted successfully` });
    } catch (error) {
        next(error);
    }
});

export default router;