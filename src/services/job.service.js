import fs from 'node:fs';
import * as path from 'path';
import { JobModel, JobStatus } from '../models/job.model.js';
import { GLOBALS } from '../configs.js';
import JobNotFoundError from '../errors/job-not-found.error.js';
import { fileService } from './file.service.js';
import ConflicError from '../errors/conflict.error.js';
import Queue from 'bull';
import Page from '../models/page.model.js';
import { PageService } from './page.service.js';
import * as epubService from "../services/epub.service.js";

const queueOptions = {
    redis: {
        host: process.env.REDIS_HOST,
        port: process.env.REDIS_PORT,
        password: process.env.REDIS_PASSWORD
    }
};

const expiryQueue = new Queue('expiryQueue', queueOptions);

export const isJobExists = (jobId) => {
    const jobRepository = getJobRepositoryPath(jobId);
    return fs.existsSync(jobRepository);
}

export const isJobRunning = (jobId) => {
    return fileService.isLockFilePresentForJob(jobId);
}

export const isJobFailed = (jobId) => {
    return fileService.isFailMarkFilePresentForJob(jobId);
}

export const runJob = async (jobId, urls, title, author, coverImageUrl) => {
    try {
        const repo = await fileService.initializeJob(jobId);
        const pages = populatePageObjs(urls);
        const pgs = new PageService(pages, repo);
        await pgs.loadPages();

        const options = {
            title: title,
            author: author || 'readify',
            publisher: 'Generated by readify app',
            version: 3,
            content: pgs.getAllContent(),
            cover: coverImageUrl || '',
        };

        const epubFilePath = path.join(repo, `${title}.epub`);
        await epubService.generateEpub(options, epubFilePath);
        fileService.cleanUpRepository(jobId);
        const expiryTime = getExpiryTime();
        expiryQueue.add({ jobId }, {
            delay: expiryTime,
            jobId: jobId
        }).catch((error) => {
            console.error("error while adding job to expiryQueue, error:", error);
        });
    } catch (error) {
        console.error('Error during running a job. Repository will be marked. Error:', error.message);
        fileService.markJobRepository(jobId);
    }
};

export const getJob = (jobId) => {
    if (!isJobExists(jobId))
        throw new JobNotFoundError(`Job with id:${jobId} not found!`);

    if (isJobRunning(jobId))
        return new JobModel(jobId, JobStatus.RUNNING, null);

    if (isJobFailed(jobId))
        return new JobModel(jobId, JobStatus.FAILED, null);

    const jobArtifact = getJobArtifactPath(jobId);
    return new JobModel(jobId, JobStatus.SUCCESS, jobArtifact);
}

export const deleteJob = async (jobId) => {
    if (!isJobExists(jobId))
        throw new JobNotFoundError(`Job with id:${jobId} not found!`);

    if (isJobRunning(jobId))
        throw new ConflicError(`Job id:${jobId} is still running`);

    fileService.deleteRepository(jobId);
    const expiryJob = await expiryQueue.getJob(jobId);
    if (expiryJob) {
        await expiryJob.remove();
        console.info("expiry job with id:", jobId, "deleted");
    }
}

function getJobRepositoryPath(jobId) {
    return path.join(GLOBALS.outputDir, jobId);
}

function getJobArtifactPath(jobId) {
    const jobRepo = getJobRepositoryPath(jobId);

    if (!jobId)
        throw new BadParamsError("jobId cannot be null or empty!");

    const files = fs.readdirSync(jobRepo);
    const epubFiles = files.filter(file => {
        return path.extname(file).toLowerCase() === '.epub';
    });

    if (epubFiles.length === 0)
        throw new ResourceNotFound(`No ePub file four for id:${jobId}`);

    else if (epubFiles.length > 1)
        throw new ConflicError(`More than one ePub file found for id:${jobId}`);

    return path.join(jobRepo, epubFiles[0]);
}

function getExpiryTime() {
    const expiryMode = process.env.EXPIRY_MODE.toUpperCase();
    const defaultTTL = 60000;

    try {
        switch (expiryMode) {
            case "RANDOM":
                const minMs = parseFloat(process.env.EXPIRY_MIN) * 60 * 1000;
                const maxMs = parseFloat(process.env.EXPIRY_MAX) * 60 * 1000;
                return Math.random() * (maxMs - minMs) + minMs;
            case "CONSTANT":
                return parseFloat(process.env.JOB_TLS);
            default:
                console.warn('invalid expiry mode set on ENV, returning default TTL value');
                return defaultTTL;
        }
    } catch (error) {
        console.error('error while retrieving expiry mode settings from ENV,', 
            'returning default TTL value. error:', error.message);
        return defaultTTL;
    }
}

function populatePageObjs(urls) {
    const pages = [];

    urls.forEach(url => {
        pages.push(new Page(url));
    });

    return pages;
}

expiryQueue.process((job, done) => {
    const { jobId } = job.data;

    try {
        console.info(jobId, 'is expired, removing its repository.');
        fileService.deleteRepository(jobId);
        done();
    } catch (error) {
        console.error('Error while cleaning up expired repository:', error.message);
    }
});